C51 COMPILER V9.00   IIC                                                                   09/20/2019 11:07:46 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE IIC
OBJECT MODULE PLACED IN IIC.OBJ
COMPILER INVOKED BY: D:\Program Files (x86)\keil\C51\BIN\C51.EXE IIC.c BROWSE DEBUG OBJECTEXTEND

line level    source

   1          #include "stc15f2k60s2.h"
   2          #include "IIC.h"
   3          
   4          #include "intrins.h"
   5                
   6          /******************************引脚定义*********************************/
   7          sbit SDA=P2^1;     //P1.0模拟I2C总线的SDA
   8          sbit SCL=P2^0;     //P1.1模拟I2C总线的SCL
   9          
  10          bit ack_mk;            //应答标志位，有应答为1，无应答为0
  11          
  12          void Delay5us()         //@11.0592MHz
  13          {
  14   1              unsigned char i;
  15   1      
  16   1              _nop_();
  17   1              i = 11;
  18   1              while (--i);
  19   1      }
  20          /*************************************************************************
  21          功能n发送起始信号
  22          入口参数：无
  23          出口参数：无
  24          **************************************************************************/
  25          void start()    
  26          {
  27   1              SDA=1;                  //将SDA、SCL置为1
  28   1              SCL=1;
  29   1              Delay5us();     //起始条件建立时间大于4.7us,故延时5us 
  30   1              SDA=0;                  //SCL为高时，SDA由高变低，发送起始信号
  31   1              Delay5us();     //延时5us
  32   1              SCL=0;                  //SCL变低，准备发送或接收数据 
  33   1      }
  34          
  35          /*************************************************************************
  36          功能n发送结束信号
  37          入口参数：无
  38          出口参数：无
  39          **************************************************************************/
  40          void stop()     
  41          { 
  42   1              SDA=0;                  //将SDA清0， SCL置1
  43   1              SCL=1;  
  44   1              Delay5us();         //结束条件建立时间大于4.7us，所以延时5us
  45   1              SDA=1;                  //当SCL为高电平时，SDA由低变高，产生结束信号
  46   1              Delay5us();     //延时5us
  47   1              SCL=0;
  48   1      }
  49          
  50          /*************************************************************************
  51          功能n产生应答信号
  52          入口参数：无
  53          出口参数：无
  54          **************************************************************************/
  55          void Ack(void)  
C51 COMPILER V9.00   IIC                                                                   09/20/2019 11:07:46 PAGE 2   

  56          { 
  57   1              SDA=0;          //SDA先清0，发应答信号 
  58   1              SCL=1;          //SCL由低变高，产生一个时钟
  59   1              Delay5us();   //延时5us
  60   1              SCL=0;          //时钟线SCL恢复到低电平，以便继续接收
  61   1      }
  62          
  63          /*************************************************************************
  64          功能n产生非应答信号
  65          入口参数：无
  66          出口参数：无
  67          **************************************************************************/
  68           void NAck(void)
  69          { 
  70   1              SDA=1;          //SDA先置1，发非应答信号 
  71   1              SCL=1;          //SCL由低变高，产生一个时钟
  72   1              Delay5us(); //延时5us
  73   1              SCL=0;          //时钟线SCL恢复到低电平，以便继续接收 
  74   1      }
  75          
  76          /*************************************************************************
  77          功能n向I2C总线发送一个字节
  78          入口参数：c 待发送字节
  79          出口参数：无
  80          **************************************************************************/
  81          void  SendByte(unsigned char c)
  82          {
  83   1              unsigned char  n ;
  84   1              for(n=0;n<8;n++)           //一字节为8位，循环8次
  85   1              {
  86   2                      if(c&0x80)
  87   2                              SDA=1;         //根据发送位将数据线SDA置为1或清0
  88   2              else 
  89   2                      SDA=0;                
  90   2              SCL=1;             //置SCL为高，通知被控从机开始接收数据位
  91   2              Delay5us();        //延时5us
  92   2              SCL=0;             //SCL变低电平，准备发送下一位数据 
  93   2              c=c<<1;            //将下一位要发送的数据移到最高位,先高后低
  94   2          }
  95   1          Delay5us();            //延时5us
  96   1          SDA=1;                 //一字节发送完后释放数据线，准备接收应答位
  97   1          Delay5us();  
  98   1          SCL=1;                 //SCL由低变高，产生一个时钟，读取SDA的状态
  99   1          Delay5us();            //延时5us
 100   1          if (SDA==1)
 101   1               ack_mk=0;         //如果SDA=1，则发送失败，将ack_mk清0
 102   1          else 
 103   1               ack_mk=1;         //否则发送成功，将ack_mk置1
 104   1          SCL=0;                                 //SCL变低
 105   1      }
 106          
 107          
 108          /*************************************************************************
 109          功能n接收一个字节
 110          入口参数：无
 111          出口参数：c 返回字节
 112          **************************************************************************/
 113          unsigned char  RcvByte()
 114          {
 115   1      
 116   1              unsigned char  c;
 117   1              unsigned char  n;
C51 COMPILER V9.00   IIC                                                                   09/20/2019 11:07:46 PAGE 3   

 118   1              SDA=1;
 119   1              for(n=0;n<8;n++)          //一字节为8位，循环8次
 120   1              {
 121   2               _nop_();
 122   2               SCL=0;
 123   2               Delay5us();
 124   2               SCL=1;
 125   2               _nop_();_nop_();
 126   2       
 127   2      
 128   2               c=c<<1;
 129   2               if(SDA==1)
 130   2                 c=c+1;
 131   2               Delay5us();
 132   2               SCL=0;
 133   2               Delay5us();     
 134   2              }
 135   1              Delay5us();
 136   1              return(c);  
 137   1      }
 138          
 139          
 140          /*************************************************************************
 141          功能n向有子地址器件发送多个字节
 142          入口参数：sla 从器件地址        suba 子地址             s 指向要发送数据                n 要发送数据的字节数
 143          出口参数：返回1表示成功，否则操作失败
 144          **************************************************************************/
 145          bit SendStr(unsigned char sla,unsigned char suba,unsigned char *s,unsigned char n)
 146          {  
 147   1              unsigned char i;
 148   1              start();                                //发起始信号，启动总线
 149   1              SendByte(sla);                          //发送器件地址
 150   1              if(ack_mk==0)return(0);         //如果没能应答，操作失败
 151   1              SendByte(suba);                         //发送器件子地址
 152   1              if(ack_mk==0)return(0);         //如果没能应答，操作失败
 153   1              for(i=0;i<n;i++)                                //循环n次
 154   1          { 
 155   2                      SendByte(*s);               //发送一个字节数据
 156   2              if(ack_mk==0)return(0);     //如果没有应答，操作失败
 157   2              s++;                                            //指向下一个字节
 158   2              } 
 159   1              stop();                             //发结束信号，结束本次数据传送 
 160   1              return(1);
 161   1      }
 162          
 163          /*************************************************************************
 164          功能n向有子地址器件读取多个字节
 165          入口参数：x 从器件地址  y 子地址        
 166          出口参数：返回读取数据
 167          **************************************************************************/
 168          unsigned char RcvStr(unsigned char x,unsigned char y)
 169          {  
 170   1              unsigned char i;
 171   1      
 172   1              start();                    //发起始信号，启动总线
 173   1              SendByte(x);             //发送器件地址
 174   1              if(ack_mk==0)return(0);         //如果没能应答，操作失败
 175   1              SendByte(y);                    //发送器件子地址
 176   1              if(ack_mk==0)return(0);         //如果没能应答，操作失败
 177   1              start();                    //再次发起始信号*/
 178   1              SendByte(x+1);                  //x+1表示对该器件进行读操作
 179   1              if(ack_mk==0)return(0);         //如果没能应答，操作失败
C51 COMPILER V9.00   IIC                                                                   09/20/2019 11:07:46 PAGE 4   

 180   1              i=RcvByte();                //接收一个字节
 181   1              NAck();                     //发送非应答信号
 182   1              stop();                     //发结束信号，结束本次数据传送
 183   1      
 184   1              return(i);
 185   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    270    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----       6
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
