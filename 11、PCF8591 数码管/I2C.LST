C51 COMPILER V9.01   I2C                                                                   10/29/2018 21:43:42 PAGE 1   


C51 COMPILER V9.01, COMPILATION OF MODULE I2C
OBJECT MODULE PLACED IN I2C.OBJ
COMPILER INVOKED BY: D:\软件\keil\C51\BIN\C51.EXE I2C.C BROWSE DEBUG OBJECTEXTEND

line level    source

   1          #include"stc15Fxxxx.h"
   2          #define  delay1us()  _nop_()       
   3          #define  delay5us()  _nop_();_nop_();_nop_();_nop_();_nop_()
   4          /******************************引脚定义*********************************/
   5          sbit SDA=P1^1;     //P1.0模拟I2C总线的SDA
   6          sbit SCL=P1^0;     //P1.1模拟I2C总线的SCL
   7          
   8          bit ack_mk;           //应答标志位，有应答为1，无应答为0
   9          
  10          /*************************************************************************
  11          功能n发送起始信号
  12          入口参数：无
  13          出口参数：无
  14          **************************************************************************/
  15          void start()    
  16          {
  17   1              SDA=1;                  //将SDA、SCL置为1
  18   1              SCL=1;
  19   1              delay5us();   //起始条件建立时间大于4.7us,故延时5us 
  20   1              SDA=0;                  //SCL为高时，SDA由高变低，发送起始信号
  21   1              delay5us();   //延时5us
  22   1              SCL=0;                  //SCL变低，准备发送或接收数据 
  23   1      }
  24          
  25          /*************************************************************************
  26          功能n发送结束信号
  27          入口参数：无
  28          出口参数：无
  29          **************************************************************************/
  30          void stop()     
  31          { 
  32   1              SDA=0;                  //将SDA清0， SCL置1
  33   1              SCL=1;  
  34   1              delay5us();     //结束条件建立时间大于4.7us，所以延时5us
  35   1              SDA=1;                  //当SCL为高电平时，SDA由低变高，产生结束信号
  36   1              delay5us();  //延时5us
  37   1              SCL=0;
  38   1      }
  39          
  40          /*************************************************************************
  41          功能n产生应答信号
  42          入口参数：无
  43          出口参数：无
  44          **************************************************************************/
  45          void Ack(void)  
  46          { 
  47   1              SDA=0;          //SDA先清0，发应答信号 
  48   1              SCL=1;          //SCL由低变高，产生一个时钟
  49   1              delay5us();   //延时5us
  50   1              SCL=0;          //时钟线SCL恢复到低电平，以便继续接收
  51   1      }
  52          
  53          /*************************************************************************
  54          功能n产生非应答信号
  55          入口参数：无
C51 COMPILER V9.01   I2C                                                                   10/29/2018 21:43:42 PAGE 2   

  56          出口参数：无
  57          **************************************************************************/
  58           void NAck(void)
  59          { 
  60   1              SDA=1;          //SDA先置1，发非应答信号 
  61   1              SCL=1;          //SCL由低变高，产生一个时钟
  62   1              delay5us(); //延时5us
  63   1              SCL=0;          //时钟线SCL恢复到低电平，以便继续接收 
  64   1      }
  65          
  66          /*************************************************************************
  67          功能n向I2C总线发送一个字节
  68          入口参数：c 待发送字节
  69          出口参数：无
  70          **************************************************************************/
  71          void  SendByte(u8 c)
  72          {
  73   1              u8  n ;
  74   1              for(n=0;n<8;n++)                //一字节为8位，循环8次
  75   1              {
  76   2                      if(c&0x80)
  77   2                              SDA=1;  //根据发送位将数据线SDA置为1或清0
  78   2              else 
  79   2                      SDA=0;                
  80   2              SCL=1;             //置SCL为高，通知被控从机开始接收数据位
  81   2              delay5us();        //延时5us
  82   2              SCL=0;             //SCL变低电平，准备发送下一位数据 
  83   2              c=c<<1;            //将下一位要发送的数据移到最高位,先高后低
  84   2          }
  85   1          delay5us();         //延时5us
  86   1          SDA=1;              //一字节发送完后释放数据线，准备接收应答位
  87   1          delay5us();  
  88   1          SCL=1;              //SCL由低变高，产生一个时钟，读取SDA的状态
  89   1          delay5us();         //延时5us
  90   1          if (SDA==1)
  91   1               ack_mk=0;      //如果SDA=1，则发送失败，将ack_mk清0
  92   1          else 
  93   1               ack_mk=1;      //否则发送成功，将ack_mk置1
  94   1          SCL=0;                              //SCL变低
  95   1      }
  96          
  97          
  98          /*************************************************************************
  99          功能n接收一个字节
 100          入口参数：无
 101          出口参数：c 返回字节
 102          **************************************************************************/
 103          u8  RcvByte()
 104          {
 105   1              u8 c;
 106   1              u8  n;
 107   1              for(n=0;n<8;n++)        //一字节为8位，循环8次
 108   1              { 
 109   2                      SDA=1;           //置数据线SDA为高,进入接收方式
 110   2              SCL=1;            //SCL由低变高，产生一个时钟
 111   2              if (SDA==0)         //根据数据线SDA的状态，将c的最高位清0或置1
 112   2                      c=c&0x7f; 
 113   2              else 
 114   2                      c=c|0x80;
 115   2              c= _crol_(c,1); //将c循环左移一位，先接收高位,后接收低位
 116   2                      SCL=0;            //时钟线SCL清0
 117   2              }
C51 COMPILER V9.01   I2C                                                                   10/29/2018 21:43:42 PAGE 3   

 118   1              return(c);
 119   1      }
 120          
 121          
 122          /*************************************************************************
 123          功能n向有子地址器件发送多个字节
 124          入口参数：sla 从器件地址        suba 子地址             s 指向要发送数据                n 要发送数据的字节数
 125          出口参数：返回1表示成功，否则操作失败
 126          **************************************************************************/
 127          bit SendStr(u8 sla,u8 suba,u8 *s,u8 n)
 128          {  
 129   1              u8 i;
 130   1              start();                                //发起始信号，启动总线
 131   1              SendByte(sla);                          //发送器件地址
 132   1              if(ack_mk==0)return(0); //如果没能应答，操作失败
 133   1              SendByte(suba);                         //发送器件子地址
 134   1              if(ack_mk==0)return(0); //如果没能应答，操作失败
 135   1              for(i=0;i<n;i++)                                //循环n次
 136   1          { 
 137   2                      SendByte(*s);              //发送一个字节数据
 138   2              if(ack_mk==0)return(0); //如果没有应答，操作失败
 139   2              s++;                                                    //指向下一个字节
 140   2              } 
 141   1              stop();                                  //发结束信号，结束本次数据传送 
 142   1              return(1);
 143   1      }
 144          
 145          /*************************************************************************
 146          功能n向有子地址器件读取多个字节
 147          入口参数：sla 从器件地址        suba 子地址             s 指向要发送数据                n 要发送数据的字节数
 148          出口参数：返回1表示成功，否则操作失败
 149          **************************************************************************/
 150          bit RcvStr(u8 sla,u8 suba,u8 *s,u8 n)
 151          {  
 152   1              u8 i;
 153   1              start();                        //发起始信号，启动总线
 154   1              SendByte(sla);                  //发送器件地址
 155   1              if(ack_mk==0)return(0);         //如果没能应答，操作失败
 156   1              SendByte(suba);                 //发送器件子地址
 157   1              if(ack_mk==0)return(0);         //如果没能应答，操作失败
 158   1              start();                        //再次发起始信号*/
 159   1              SendByte(sla+1);                //sla+1表示对该器件进行读操作
 160   1              if(ack_mk==0)return(0);         //如果没能应答，操作失败
 161   1              for(i=0;i<n-1;i++)                      //对前no-1个字节发应答信号
 162   1              { 
 163   2                      *s=RcvByte();                   //接收数据
 164   2                      Ack();                     //发送应答信号  
 165   2                      s++;
 166   2              } 
 167   1              *s=RcvByte();              //接收最后一个字节
 168   1              NAck();                     //发送非应答信号
 169   1              stop();                     //发结束信号，结束本次数据传送
 170   1              return(1);
 171   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    297    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----      12
C51 COMPILER V9.01   I2C                                                                   10/29/2018 21:43:42 PAGE 4   

   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
