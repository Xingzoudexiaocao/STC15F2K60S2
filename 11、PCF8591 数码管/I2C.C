#include"stc15Fxxxx.h"
#define  delay1us()  _nop_()       
#define  delay5us()  _nop_();_nop_();_nop_();_nop_();_nop_()
/******************************引脚定义*********************************/
sbit SDA=P1^1;     //P1.0模拟I2C总线的SDA
sbit SCL=P1^0;     //P1.1模拟I2C总线的SCL

bit ack_mk;	      //应答标志位，有应答为1，无应答为0

/*************************************************************************
功能n发送起始信号
入口参数：无
出口参数：无
**************************************************************************/
void start()	
{
	SDA=1;   		//将SDA、SCL置为1
	SCL=1;
	delay5us();   //起始条件建立时间大于4.7us,故延时5us 
	SDA=0;   		//SCL为高时，SDA由高变低，发送起始信号
 	delay5us();   //延时5us
	SCL=0;   		//SCL变低，准备发送或接收数据 
}

/*************************************************************************
功能n发送结束信号
入口参数：无
出口参数：无
**************************************************************************/
void stop()  	
{ 
	SDA=0;  		//将SDA清0， SCL置1
 	SCL=1;  
 	delay5us();	//结束条件建立时间大于4.7us，所以延时5us
 	SDA=1;  		//当SCL为高电平时，SDA由低变高，产生结束信号
 	delay5us();  //延时5us
	SCL=0;
}

/*************************************************************************
功能n产生应答信号
入口参数：无
出口参数：无
**************************************************************************/
void Ack(void)  
{ 
	SDA=0;     	//SDA先清0，发应答信号 
	SCL=1;    	//SCL由低变高，产生一个时钟
	delay5us();   //延时5us
 	SCL=0;     	//时钟线SCL恢复到低电平，以便继续接收
}

/*************************************************************************
功能n产生非应答信号
入口参数：无
出口参数：无
**************************************************************************/
 void NAck(void)
{ 
	SDA=1;     	//SDA先置1，发非应答信号 
	SCL=1;     	//SCL由低变高，产生一个时钟
	delay5us(); //延时5us
	SCL=0;     	//时钟线SCL恢复到低电平，以便继续接收 
}

/*************************************************************************
功能n向I2C总线发送一个字节
入口参数：c 待发送字节
出口参数：无
**************************************************************************/
void  SendByte(u8 c)
{
	u8  n ;
	for(n=0;n<8;n++)  		//一字节为8位，循环8次
	{
		if(c&0x80)
 			SDA=1; 	//根据发送位将数据线SDA置为1或清0
     	else 
     		SDA=0;                
     	SCL=1;             //置SCL为高，通知被控从机开始接收数据位
     	delay5us();        //延时5us
     	SCL=0;             //SCL变低电平，准备发送下一位数据 
     	c=c<<1;            //将下一位要发送的数据移到最高位,先高后低
    }
    delay5us();         //延时5us
    SDA=1;              //一字节发送完后释放数据线，准备接收应答位
    delay5us();  
    SCL=1;              //SCL由低变高，产生一个时钟，读取SDA的状态
    delay5us();         //延时5us
    if (SDA==1)
         ack_mk=0;    	//如果SDA=1，则发送失败，将ack_mk清0
    else 
         ack_mk=1;      //否则发送成功，将ack_mk置1
    SCL=0;				//SCL变低
}


/*************************************************************************
功能n接收一个字节
入口参数：无
出口参数：c 返回字节
**************************************************************************/
u8  RcvByte()
{
	u8 c;
	u8  n;
	for(n=0;n<8;n++) 	//一字节为8位，循环8次
	{ 
		SDA=1;           //置数据线SDA为高,进入接收方式
     	SCL=1;            //SCL由低变高，产生一个时钟
     	if (SDA==0) 	    //根据数据线SDA的状态，将c的最高位清0或置1
        	c=c&0x7f; 
     	else 
        	c=c|0x80;
     	c= _crol_(c,1); //将c循环左移一位，先接收高位,后接收低位
	 	SCL=0;            //时钟线SCL清0
	}
	return(c);
}


/*************************************************************************
功能n向有子地址器件发送多个字节
入口参数：sla 从器件地址	suba 子地址		s 指向要发送数据		n 要发送数据的字节数
出口参数：返回1表示成功，否则操作失败
**************************************************************************/
bit SendStr(u8 sla,u8 suba,u8 *s,u8 n)
{  
	u8 i;
	start();                  		//发起始信号，启动总线
	SendByte(sla);          	 	//发送器件地址
	if(ack_mk==0)return(0);	//如果没能应答，操作失败
	SendByte(suba);         		//发送器件子地址
	if(ack_mk==0)return(0);	//如果没能应答，操作失败
	for(i=0;i<n;i++) 				//循环n次
    { 
		SendByte(*s);              //发送一个字节数据
      	if(ack_mk==0)return(0);	//如果没有应答，操作失败
      	s++;							//指向下一个字节
	} 
	stop();                  		 //发结束信号，结束本次数据传送 
	return(1);
}

/*************************************************************************
功能n向有子地址器件读取多个字节
入口参数：sla 从器件地址	suba 子地址		s 指向要发送数据		n 要发送数据的字节数
出口参数：返回1表示成功，否则操作失败
**************************************************************************/
bit RcvStr(u8 sla,u8 suba,u8 *s,u8 n)
{  
	u8 i;
	start();                     	//发起始信号，启动总线
	SendByte(sla);             	//发送器件地址
	if(ack_mk==0)return(0); 	//如果没能应答，操作失败
	SendByte(suba);            	//发送器件子地址
	if(ack_mk==0)return(0); 	//如果没能应答，操作失败
	start();                    	//再次发起始信号*/
	SendByte(sla+1);           	//sla+1表示对该器件进行读操作
	if(ack_mk==0)return(0); 	//如果没能应答，操作失败
	for(i=0;i<n-1;i++)       		//对前no-1个字节发应答信号
	{ 
		*s=RcvByte();           	//接收数据
		Ack();                     //发送应答信号  
		s++;
	} 
	*s=RcvByte();              //接收最后一个字节
	NAck();                     //发送非应答信号
	stop();                     //发结束信号，结束本次数据传送
	return(1);
}
